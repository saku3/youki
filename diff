diff --git a/crates/libcontainer/src/container/mod.rs b/crates/libcontainer/src/container/mod.rs
index 1e828a2a..c13a5f53 100644
--- a/crates/libcontainer/src/container/mod.rs
+++ b/crates/libcontainer/src/container/mod.rs
@@ -20,4 +20,6 @@ pub mod state;
 pub mod tenant_builder;
 pub use container::{CheckpointOptions, Container};
 pub use container_checkpoint::CheckpointError;
-pub use state::{ContainerProcessState, ContainerStatus, State};
+#[allow(deprecated)]
+pub use state::ContainerProcessState;
+pub use state::{ContainerStatus, State};
diff --git a/crates/libcontainer/src/container/state.rs b/crates/libcontainer/src/container/state.rs
index 4f0bc07a..0e40fff7 100644
--- a/crates/libcontainer/src/container/state.rs
+++ b/crates/libcontainer/src/container/state.rs
@@ -7,6 +7,7 @@ use std::io::{BufReader, BufWriter, Write};
 use std::path::{Path, PathBuf};
 
 use chrono::{DateTime, Utc};
+use oci_spec::runtime::VERSION as OCI_RUNTIME_VERSION;
 use serde::{Deserialize, Serialize};
 use tracing::instrument;
 
@@ -128,7 +129,7 @@ impl State {
         bundle: PathBuf,
     ) -> Self {
         Self {
-            oci_version: "v1.0.2".to_string(),
+            oci_version: OCI_RUNTIME_VERSION.to_string(),
             id: container_id.to_string(),
             status,
             pid,
@@ -233,6 +234,11 @@ impl State {
     }
 }
 
+/// Deprecated: Use [`oci_spec::runtime::ContainerProcessState`] instead.
+#[deprecated(
+    since = "0.6.0",
+    note = "Use oci_spec::runtime::ContainerProcessState instead"
+)]
 #[derive(Serialize, Deserialize, Debug, Default)]
 #[serde(rename_all = "camelCase")]
 pub struct ContainerProcessState {
diff --git a/crates/libcontainer/src/process/container_main_process.rs b/crates/libcontainer/src/process/container_main_process.rs
index 019bdff8..443a60c3 100644
--- a/crates/libcontainer/src/process/container_main_process.rs
+++ b/crates/libcontainer/src/process/container_main_process.rs
@@ -7,6 +7,8 @@ use std::path::PathBuf;
 use nix::sys::wait::{WaitStatus, waitpid};
 use nix::unistd::Pid;
 use oci_spec::runtime::{Linux, LinuxNamespaceType};
+#[cfg(feature = "libseccomp")]
+use oci_spec::runtime::{SECCOMP_FD_NAME, VERSION as OCI_VERSION};
 
 use crate::hooks;
 use crate::network::network_device::dev_change_net_namespace;
@@ -42,6 +44,8 @@ pub enum ProcessError {
     SyscallOther(#[source] SyscallError),
     #[error("failed hooks {0}")]
     Hooks(#[from] crate::hooks::HookError),
+    #[error("failed to build OCI state: {0}")]
+    OciStateBuild(String),
 }
 
 type Result<T> = std::result::Result<T, ProcessError>;
@@ -183,19 +187,36 @@ pub fn container_main_process(container_args: &ContainerArgs) -> Result<(Pid, bo
 
         #[cfg(feature = "libseccomp")]
         if let Some(seccomp) = linux.seccomp() {
-            let state = crate::container::ContainerProcessState {
-                oci_version: container_args.spec.version().to_string(),
-                // runc hardcode the `seccompFd` name for fds.
-                fds: vec![String::from("seccompFd")],
-                pid: init_pid.as_raw(),
-                metadata: seccomp.listener_metadata().to_owned().unwrap_or_default(),
-                state: container_args
-                    .container
-                    .as_ref()
-                    .ok_or(ProcessError::ContainerStateRequired)?
-                    .state
-                    .clone(),
+            let container = container_args
+                .container
+                .as_ref()
+                .ok_or(ProcessError::ContainerStateRequired)?;
+
+            // Determine OCI status based on container type (matching runc behavior)
+            let oci_status = match container_args.container_type {
+                ContainerType::InitContainer => oci_spec::runtime::ContainerState::Creating,
+                ContainerType::TenantContainer { .. } => oci_spec::runtime::ContainerState::Running,
             };
+
+            // Build OCI-compliant ContainerProcessState using builder pattern
+            let oci_state = oci_spec::runtime::StateBuilder::default()
+                .version(OCI_VERSION)
+                .id(container.state.id.clone())
+                .status(oci_status)
+                .pid(init_pid.as_raw())
+                .bundle(container.state.bundle.clone())
+                .annotations(container.state.annotations.clone().unwrap_or_default())
+                .build()
+                .map_err(|e| ProcessError::OciStateBuild(e.to_string()))?;
+
+            let state = oci_spec::runtime::ContainerProcessStateBuilder::default()
+                .version(OCI_VERSION)
+                .fds(vec![SECCOMP_FD_NAME.to_string()])
+                .pid(init_pid.as_raw())
+                .metadata(seccomp.listener_metadata().clone().unwrap_or_default())
+                .state(oci_state)
+                .build()
+                .map_err(|e| ProcessError::OciStateBuild(e.to_string()))?;
             crate::process::seccomp_listener::sync_seccomp(
                 seccomp,
                 &state,
diff --git a/crates/libcontainer/src/process/seccomp_listener.rs b/crates/libcontainer/src/process/seccomp_listener.rs
index c24767e7..7308e19f 100644
--- a/crates/libcontainer/src/process/seccomp_listener.rs
+++ b/crates/libcontainer/src/process/seccomp_listener.rs
@@ -7,7 +7,6 @@ use nix::unistd;
 use oci_spec::runtime;
 
 use super::channel;
-use crate::container::ContainerProcessState;
 use crate::seccomp;
 
 #[derive(Debug, thiserror::Error)]
@@ -26,7 +25,7 @@ type Result<T> = std::result::Result<T, SeccompListenerError>;
 
 pub fn sync_seccomp(
     seccomp: &runtime::LinuxSeccomp,
-    state: &ContainerProcessState,
+    state: &runtime::ContainerProcessState,
     init_sender: &mut channel::InitSender,
     main_receiver: &mut channel::MainReceiver,
 ) -> Result<()> {
@@ -115,7 +114,6 @@ mod tests {
     use serial_test::serial;
 
     use super::*;
-    use crate::container::ContainerProcessState;
     use crate::process::channel;
 
     #[test]
@@ -144,7 +142,24 @@ mod tests {
         let socket_path = tmp_dir.path().join("socket_file.sock");
         let socket_path_seccomp_th = socket_path.clone();
 
-        let state = ContainerProcessState::default();
+        let state = runtime::ContainerProcessStateBuilder::default()
+            .version("1.0.0".to_string())
+            .fds(vec!["seccompFd".to_string()])
+            .pid(1234)
+            .metadata("test".to_string())
+            .state(
+                runtime::StateBuilder::default()
+                    .version("1.0.0".to_string())
+                    .id("test-container".to_string())
+                    .status(runtime::ContainerState::Creating)
+                    .pid(1234)
+                    .bundle(std::path::PathBuf::from("/tmp/bundle"))
+                    .annotations(std::collections::HashMap::new())
+                    .build()
+                    .unwrap(),
+            )
+            .build()
+            .unwrap();
         let want = serde_json::to_string(&state)?;
         let th = thread::spawn(move || {
             sync_seccomp(
diff --git a/tests/contest/contest/src/tests/seccomp_notify/mod.rs b/tests/contest/contest/src/tests/seccomp_notify/mod.rs
index 0936ec2b..52bf6391 100644
--- a/tests/contest/contest/src/tests/seccomp_notify/mod.rs
+++ b/tests/contest/contest/src/tests/seccomp_notify/mod.rs
@@ -82,15 +82,15 @@ fn test_seccomp_notify() -> Result<()> {
             None => return TestResult::Failed(anyhow!("state command returned error")),
         };
 
-        if state.id != container_process_state.state.id {
+        if state.id != *container_process_state.state().id() {
             return TestResult::Failed(anyhow!("container id doesn't match"));
         }
 
-        if state.pid.unwrap() != container_process_state.pid {
+        if state.pid.unwrap() != *container_process_state.pid() {
             return TestResult::Failed(anyhow!("container process id doesn't match"));
         }
 
-        if SECCOMP_METADATA != container_process_state.metadata {
+        if SECCOMP_METADATA != container_process_state.metadata().as_deref().unwrap_or("") {
             return TestResult::Failed(anyhow!("seccomp listener metadata doesn't match"));
         }
 
diff --git a/tests/contest/contest/src/tests/seccomp_notify/seccomp_agent.rs b/tests/contest/contest/src/tests/seccomp_notify/seccomp_agent.rs
index 5d16a9ba..a3567724 100644
--- a/tests/contest/contest/src/tests/seccomp_notify/seccomp_agent.rs
+++ b/tests/contest/contest/src/tests/seccomp_notify/seccomp_agent.rs
@@ -4,9 +4,9 @@ use std::os::unix::prelude::RawFd;
 use std::path::Path;
 
 use anyhow::{Context, Result, bail};
-use libcontainer::container::ContainerProcessState;
 use nix::sys::socket::{self, Backlog, UnixAddr};
 use nix::unistd;
+use oci_spec::runtime::ContainerProcessState;
 
 const DEFAULT_BUFFER_SIZE: usize = 4096;
 
@@ -87,9 +87,8 @@ pub fn recv_seccomp_listener(seccomp_listener: &Path) -> SeccompAgentResult {
 
     buf.truncate(msg_bytes);
 
-    let container_process_state: libcontainer::container::ContainerProcessState =
-        serde_json::from_slice(&buf[..])
-            .context("failed to parse the received message as container process state")?;
+    let container_process_state: ContainerProcessState = serde_json::from_slice(&buf[..])
+        .context("failed to parse the received message as container process state")?;
 
     Ok((container_process_state, fd))
 }
